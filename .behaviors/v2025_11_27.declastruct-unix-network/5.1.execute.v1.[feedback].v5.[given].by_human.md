emit your response into .behaviors/v2025_11_27.declastruct-unix-network/5.1.execute.v1.[feedback].v5.[taken].by_robot.md

the response should consist of
1. your plan to address the feedback; e.g., create your checklist
2. your execution of the plan; i.e., do each step
3. your confirmation of execution of the plan; i.e., check each step off with citation of the changes


---

reboot your mechanics briefs first.

npx rhachet roles boot --repo ehmpathy --role mechanic

then address the blockers and nitpicks below

---

# blocker.1

in tests

 dont use a tmpdir; use `./.test/.temp`, scoped within that local dir that the test lives in, so that we can see the diffs locally => observe them

---

# blocker.2


        // create initial file
        await writeFile(tempHostsPath, '127.0.0.1\tlocalhost\n');

initial states should go within `beforeAll` inside the `given` block

that way its clear
- what's part of the initial scene that the test runs in
- vs
- what's part of the test


---

# blocker.3

dont support multiple hosts per line on the add operation; its fine on the get, since technically their system may already have that, but we dont want to support a propogation of this


        await addOsUnixHostsFileLine(
          {
            line: {
              ip: '10.0.0.1',
              hostnames: ['server1', 'server2', 'server3'],
            },
          },
          { override: { etcHostsPath: tempHostsPath } },
        );


we only want to support lines with one host at a time, to simplify maintenance and maximize isolation


----

# blocker.4

formatOsUnixHostsFileLine => castFromOsUnixHostsFileLine

to represent that we're casting from the Shape into the string line

put it into its own file too, so that the test file clearly shows which procedure its testing

----

# blocker.5

same with `parseOsUnixHostsFileLine`

parseOsUnixHostsFileLine => castIntoOsUnixHostsFileLine

and into its own file too


----

# blocker.6

rather than multiline expect includes

use a multiline includes

or an inline snapshot

e.g., here

          expect(result).toContain(expected.containsDescription);
          expect(result).toContain(expected.containsExecStart);
          expect(result).toContain(expected.containsUnit);
          expect(result).toContain(expected.containsService);
          expect(result).toContain(expected.containsInstall);

and here


        expect(content).toContain('[Unit]');
        expect(content).toContain(
          'Description=Declastruct socat port forward 127.0.0.1:5432 -> 127.0.0.1:15432',
        );
        expect(content).toContain('[Service]');
        expect(content).toContain(
          'ExecStart=/usr/bin/socat TCP-LISTEN:5432,bind=127.0.0.1,fork,reuseaddr TCP:127.0.0.1:15432',
        );
        expect(content).toContain('[Install]');
        expect(content).toContain('WantedBy=multi-user.target');

and etc


----

# blocker.7

the unit tests here src/access/sdks/osUnixSystemdSocat/dop.addOsUnixSystemdSocatService.test.ts

should prove that if sudo is required, then

1. runs with sudo
2. will enable the service


---

# blocker.8

src/domain.operations/hostAlias/replaceOsUnixHostsFileLine.ts

should be within the sdk

there should be no OsUnixHostsFileLine operations within the src/domain.operations anymore

and of course, it should be covered with tests


input: { oldLine: string; newLine: string },

it should operate in terms of the `OsUnixHostsFileLine` domain objects

and it should not duplicate the DEFUALT_HOSTS constant; it should import from a common place

ðŸ”´ðŸ”´ðŸ”´ðŸ”´ðŸ”´


----

# blocker.9



  parseOsUnixSystemdSocatService,
  formatOsUnixSystemdSocatService,


  parseOsUnixHostsFileLine,
  formatOsUnixHostsFileLine,


these should not be exported from the sdks, because only the sdks should be allowed to operate against the file line strings directly

everything else should go through the sdk's domain-operations (dops) for safety and separation of concerns


=====


# blocker.10


  // if upsert and found with different target, update by overwriting the service file
  // (systemd services are naturally idempotent - writing the same file again is safe)
  if (
    found &&
    input.upsert &&
    (found.into.host !== desired.into.host ||
      found.into.port !== desired.into.port)
  ) {
    const service = castFromDeclaredUnixPortAlias({ alias: desired });
    // use the found service name to overwrite the correct file
    service.serviceName = found.name ?? service.serviceName;
    await addOsUnixSystemdSocatService({ service }, context);
    return new DeclaredUnixPortAlias({
      via: 'systemd-socat',
      from: new UnixPortEndpoint(desired.from),
      into: new UnixPortEndpoint(desired.into),
      name: service.serviceName,
    });
  }

if this is true, then rename `addOsUnixSystemdSocatService` as `setOsUnixSystemdSocatService`

and cover the update operation with tests within the sdk layer

and make it clear in the comments too of that operation


=======

blocker.11

never mutate values!

```ts

    // use the found service name to overwrite the correct file
    service.serviceName = found.name ?? service.serviceName;
    await addOsUnixSystemdSocatService({ service }, context);
    return new DeclaredUnixPortAlias({
      via: 'systemd-socat',
      from: new UnixPortEndpoint(desired.from),
      into: new UnixPortEndpoint(desired.into),
      name: service.serviceName,
    });


```
is banned!

just remove the service name entirely from the `DeclaredUnixPortAlias` declaration since we cant manage it ourselves

and instead pass it in as `found.name ?? generate` if not found
