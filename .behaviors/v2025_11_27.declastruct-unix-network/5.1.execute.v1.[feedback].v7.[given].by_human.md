emit your response into .behaviors/v2025_11_27.declastruct-unix-network/5.1.execute.v1.[feedback].v7.[taken].by_robot.md

the response should consist of
1. your plan to address the feedback; e.g., create your checklist
2. your execution of the plan; i.e., do each step
3. your confirmation of execution of the plan; i.e., check each step off with citation of the changes


---

# blocker.1

    if (needsSudo) {
      const { stdout } = await execa('sudo', ['cat', input.uri]);
      return stdout;
    } else {
      return await readFile(input.uri, 'utf-8');
    }


eliminate all cases where if (needsSudo) we execa but else dont

we should alwys execa in all cases, to maximize the consistency of the codepaths

eliminate all suchcases

search by `if (needsSudo)`


---

# blocker.2


export const castFromDeclaredUnixPortAlias = (input: {
  alias: DeclaredUnixPortAlias;
  unitDir: string;
}): OsUnixSystemdSocatService => {


unitDir should come from context: ContextUnixNetwork

it should evaluate the override itself


---

# blocker.3

in
  // if upsert and found with different target, update by overwriting the service file
  // (systemd services are naturally idempotent - writing the same file again is safe)
  // (uri is deterministically derived from from endpoint, so it stays the same)
  if (
    found &&
    input.upsert &&
    (found.into.host !== desired.into.host ||
      found.into.port !== desired.into.port)
  ) {
    await osUnixSystemdSocatSdk.setOsUnixSystemdSocatService(
      { service },
      context,
    );
    return new DeclaredUnixPortAlias({ ...desired, uri: service.uri });
  }

  // not found - add via SDK
  await osUnixSystemdSocatSdk.setOsUnixSystemdSocatService(
    { service },
    context,
  );

  return new DeclaredUnixPortAlias({ ...desired, uri: service.uri });


  looks like we do the same exact operaiton whether it had changes or not

  so... remove the extra if block and make it clear we do it whehter its found or not, if its an upsert



---

# blocker.4


  // determine unit directory
  const unitDir =
    context?.override?.systemdUnitsDir ?? DEFAULT_SYSTEMD_UNIT_DIR;


context should no longer make those optional

it should ask for them to always be declared

and instead of calling them overrides, just call them `repos`

e.g.,

`context.osUnixNetwork.repo.systemdUnitsDir` &&
`context.osUnixNetwork.repo.etcHostsPath`,


then, in getProvider, it should set the defaults
