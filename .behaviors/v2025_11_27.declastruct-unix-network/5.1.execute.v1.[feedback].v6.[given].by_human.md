emit your response into .behaviors/v2025_11_27.declastruct-unix-network/5.1.execute.v1.[feedback].v5.[taken].by_robot.md

the response should consist of
1. your plan to address the feedback; e.g., create your checklist
2. your execution of the plan; i.e., do each step
3. your confirmation of execution of the plan; i.e., check each step off with citation of the changes


---

# blocker.1

lets make the distinction between OsUnixHostsFileLine and OsUnixHostsFileEntry clear

export type OsUnixHostsFileLine = string

and lets rename

```ts

/**
 * .what = parsed line from /etc/hosts file using the OS's native format
 * .why = intermediate representation for hosts file operations at the OS access layer
 *
 * .note = represents the raw structure of a hosts file line:
 *   - format: `<ip> <hostname1> [hostname2...] [# comment]`
 *   - no usecase-specific attributes; only what the OS exposes
 *
 * @see https://man7.org/linux/man-pages/man5/hosts.5.html
 */
export interface OsUnixHostsFileLine {
  ...
```

as

`OsUnixHostsFileEntry`



----


# blocker.2

dont create a new interface for src/access/sdks/osUnixHostsFile/dobj.OsUnixHostsFileLineInput.ts

instead, in the `add` operation, just runtime failfast if someone gives more than one as an input

that's sufficient


this means no more


/**
 * .what = formats an OsUnixHostsFileLineInput as a raw hosts file line string
 * .why = internal helper to convert input to hosts file format for writing
 */
const formatLine = (input: { line: OsUnixHostsFileLineInput }): string => {
  const { line } = input;
  const commentStr = line.comment ? `\t# ${line.comment}` : '';
  return `${line.ip}\t${line.hostname}${commentStr}`;
};

too.

should be via castInto/castFrom OsUnixHostsFileEntry

i.e.,

formatLine = castFromOsUnixHostsFileEntry


----

# blocker.3


/**
 * .what = SDK for accessing /etc/hosts file
 * .why = provides structured operations on the OS hosts file
 */
export const osUnixHostsFileSdk = {
  getOsUnixHostsFileLines,
  addOsUnixHostsFileLine,
};


MUST keep the `export const osUnixHostsFileSdk = {` interface

everything should use the sdk via `osUnixHostsFileSdk`, not direct imports


same for systemdSocat


-----

# blocker.4

in replace


    // write via sudo
    await execa('sudo', ['tee', hostsPath], {
      input: newContent,
    });


wouldnt that append? not replace? sincei t uses tee?

fix or leave a comment that explains clearly


----

# blocker.5

make things consistent

instead of


  if (needsSudo) {
    // append using sudo tee -a (append mode)
    await execa('sudo', ['tee', '-a', hostsPath], {
      input: lineContent,
    });
  } else {
    // direct write for test files
    await appendFile(hostsPath, lineContent);
  }

which uses appendFile for non sudo and execa for sudo

always use execa for consistency

and just omit sudo when not needed


do that for every write operation where that pattern is applicable


---

# blocker.6


export interface OsUnixSystemdSocatService {
  /**
   * .what = systemd service unit name
   * .why = identifies the service file in /etc/systemd/system/
   */
  serviceName: string;


instead of `serviceName`

just call that `uri` which identifies the exact path of that file in the system


THEN

use that to expose _on read_ that same uri as optional metadata on `DeclaredUnixPortAlias`

i.e.,


/**
 * .what = a declarative structure which represents a unix port alias (port forwarding)
 * .why = enables declarative management of systemd-socat services following declastruct patterns
 */
export interface DeclaredUnixPortAlias {
  /**
   * .note = is @metadata -> only known after persistence, autogenerated
   */
  uri?: string;

  /**
   * .what = mechanism used to manage the port forwarding
   * .note = currently only 'systemd-socat' is supported
   */
  via: 'systemd-socat';

  /**
   * .what = source endpoint to listen on
   */
  from: UnixPortEndpoint;

  /**
   * .what = target endpoint to forward to
   */
  into: UnixPortEndpoint;
}

export class DeclaredUnixPortAlias
  extends DomainEntity<DeclaredUnixPortAlias>
  implements DeclaredUnixPortAlias
{
  public static primary = ['uri'] as const;
  public static unique = ['via', 'from'] as const;
  public static nested = {
    from: UnixPortEndpoint,
    into: UnixPortEndpoint,
  };
}


----

# blocker.7

the nonsudo path here should look closer to the sudo path too


  if (needsSudo) {
    // write service unit file via sudo
    await execa('sudo', ['tee', unitPath], {
      input: content,
    });

    // reload systemd daemon
    await execa('sudo', ['systemctl', 'daemon-reload']);

    // enable and start service
    await execa('sudo', [
      'systemctl',
      'enable',
      `${input.service.serviceName}.service`,
    ]);
    await execa('sudo', [
      'systemctl',
      'restart',
      `${input.service.serviceName}.service`,
    ]);
  } else {
    // direct write for test files (no systemctl operations)
    await writeFile(unitPath, content);
  }


that way our nonsudo tests are more representative of the sudo behavior

e.g.,

should still use execa; it should just omit the sudo prefix and skip the systemctl related commands after the write



