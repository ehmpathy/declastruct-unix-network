emit your response into .behaviors/v2025_11_27.declastruct-unix-network/5.1.execute.v1.[feedback].v4.[taken].by_robot.md

the response should consist of
1. your plan to address the feedback; e.g., create your checklist
2. your execution of the plan; i.e., do each step
3. your confirmation of execution of the plan; i.e., check each step off with citation of the changes

---

# blocker.1

src/access/sdks/osUnixHostsFile/dop.getOsUnixHostsFileLines.test.ts is not implemented

unimplemented tests are a BLOCKER violation

for this test, mock out the getHosts file read and give it example contentts that we need to support

i.e.,

use the data driven test cases pattern and give several examples of

given:
- osHostsFileContent = X
then:
- expect: lines = Y


---

# blocker.2

add unit tests for each dop in the sdks

- for osUnixHostsFile
and
- for osUnixSystemdSocat


---

# blocker.3

add integration tests for each dop in the sdks

- for osUnixHostsFile
and
- for osUnixSystemdSocat



  3. use a temp file for integration tests
  // inject file path
  export const addOsUnixHostsFileLine = async (
    input: { line: OsUnixHostsFileLine },
    context?: { hostsPath?: string }
  ) => {
    const hostsPath = context?.hostsPath ?? '/etc/hosts';
    // if custom path, no sudo needed
    const needsSudo = hostsPath === '/etc/hosts';
    // ...
  };


update `ContextUnixNetwork` in over to support attributes

```
interface ContextUnixNetwork {
  override?: {
    etcHostsPath?:  string,
    systemdUnitsDir?: | string,
  }
}
```

in order to facilitate that via dep injection via context


----


# blocker.4

  } catch {
    return [];
  }

stop silent-failures; they're critical defect hazards

fail fast whenever something unexpected happens

this is the most important thing that you should remember always


in cases where we expect a specific error, guard for that specific error


  } catch {
    // service file doesn't exist
    return null;
  }

->


  } catch(error) {
    if (!(error instanceof Error)) throw error;

    // handle if service file doesn't exist
    if (error.message.include("XYZ"))
    return null;

    // otherwise, we dont know what went wrong
    throw error
  }


but NEVER failhide

always failfast



----

# blocker.5

stop scopeing to only the resources declastruct manages

    ? lines.filter((line) => isManagedByDeclastruct({ line }))


we want to manage EVERYTHING

against the source of truth

that's the point of declastruct;

manage reality, regardless of who started it

full declarative control via declarative instructions



----

# blocker.6

stop scopeing to only the resources declastruct manages

      '-c',
      `ls ${SYSTEMD_UNIT_DIR}/declastruct-socat-*.service 2>/dev/null || true`,


we want to manage EVERYTHING

against the source of truth

that's the point of declastruct;

manage reality, regardless of who started it

full declarative control via declarative instructions




------

# blocker.7

never use term `existing`, as its a gerund

use the term `found` instead


-----

# blocker.8

distinguish `getOne` vs `getAll`

rather than ia suffix

i.e.,

- src/domain.operations/hostAlias/getUnixHostAlias.ts => src/domain.operations/hostAlias/getOneUnixHostAlias.ts
- src/domain.operations/hostAlias/getUnixHostAliases.ts => src/domain.operations/hostAlias/getAllUnixHostAlias.ts

same with port aliasess


----

# blocker.9


  // if upsert and exists with different target, fail fast
  if (
    existing &&
    input.upsert &&
    (existing.into.host !== desired.into.host ||
      existing.into.port !== desired.into.port)
  ) {
    BadRequestError.throw(
      'cannot upsert port alias; entry exists with different target. delete first.',
      { existing, desired },
    );
  }


...

support updates; both for portAlias and hostAlias

do it safely; ctrl-f replace; fail fast if cant replace

=>

minimum changes
